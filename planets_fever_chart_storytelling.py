# -*- coding: utf-8 -*-
"""Planets_Fever_Chart_Storytelling.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1IRp4FsKLroAGKf4O1tZl8-XwE197VhkI

# üåç Planet‚Äôs Fever Chart ‚Äî Climate Data Storytelling (NASA GISTEMP)

**Goal:** turn climate data into a compelling story using visuals + a mini interactive dashboard.

**You will:**
- Load global temperature anomaly data from **NASA GISTEMP** (annual means).
- Build a clear **'fever chart'** line visualization.
- Add **interactive controls** (smoothing window, year range, threshold lines).
- Craft a short narrative: *Setup ‚Üí Conflict ‚Üí Resolution*.
"""

# === Cell 1: Setup & Imports ===
# (Run this once per session)
!pip -q install plotly>=5.22 ipywidgets>=8.1
!pip install prophet

import pandas as pd
import numpy as np
import plotly.express as px
import plotly.graph_objects as go
import plotly.io as pio
from ipywidgets import widgets, HBox, VBox, Layout, interactive_output
from IPython.display import display, Markdown

# Render Plotly in notebook/Colab
pio.renderers.default = "colab"

# Enable the widget manager in Colab (safe if not in Colab)
try:
    from google.colab import output
    output.enable_custom_widget_manager()
except Exception:
    pass

print("Setup complete.")

"""# Column Description:

Each data point includes the following:

| Column      | Meaning                                    |
| ----------- | ------------------------------------------ |
| **Year**    | The calendar year (1880‚Äì2025).             |
| **Jan‚ÄìDec** | Monthly global temperature anomalies (¬∞C). |
| **J‚ÄìD**     | Annual mean (January‚ÄìDecember).            |
| **D‚ÄìN**     | Annual mean (December‚ÄìNovember).           |
| **DJF**     | Winter (December‚ÄìFebruary) seasonal mean.  |
| **MAM**     | Spring (March‚ÄìMay) mean.                   |
| **JJA**     | Summer (June‚ÄìAugust) mean.                 |
| **SON**     | Autumn (September‚ÄìNovember) mean.          |

"""

# === Cell 2: Load NASA GISTEMP global temperature anomaly data ===
# Source: https://data.giss.nasa.gov/gistemp/
# Direct CSV: https://data.giss.nasa.gov/gistemp/tabledata_v4/GLB.Ts+dSST.csv

import io, requests
from google.colab import drive

drive.mount('/content/drive')
df = pd.read_csv("/content/drive/MyDrive/Python_Pizza_Event/GLB.Ts+dSST.csv", skiprows=1)
df = df.rename(columns=lambda c: c.strip())
df = df[df["Year"].astype(str).str.match(r"^\d{4}$", na=False)]
data = df
df["Year"] = df["Year"].astype(int)
df["J-D"] = pd.to_numeric(df["J-D"], errors="coerce")
df = df.dropna(subset=["J-D"]).copy()
df = df[df["Year"] >= 1880]
df = df.rename(columns={"J-D": "Anomaly"})
df = df[["Year","Anomaly"]].reset_index(drop=True)
print(df.head(10))

# === Cell 3: Quick EDA & Context ===
print("Data rows:", len(df), "| Year range:", df['Year'].min(), "‚Üí", df['Year'].max())
display(df.describe().T)

# Rolling means for optional smoothing
df['Anomaly_5yr'] = df['Anomaly'].rolling(window=5, center=True, min_periods=1).mean()
df['Anomaly_10yr'] = df['Anomaly'].rolling(window=10, center=True, min_periods=1).mean()

last_year = int(df['Year'].max())
last_val = float(df.loc[df['Year']==last_year, 'Anomaly'].iloc[0])
Markdown(f"""**Latest (~{last_year}) anomaly:** {last_val:.2f} ¬∞C relative to 1951‚Äì1980 baseline.""")

# === Cell 4: Absolute temperature series from anomalies ===
BASELINE_C = 14.0  # 1951‚Äì1980 global mean (approx) by NASA
df["Absolute_Temp"] = BASELINE_C + df["Anomaly"]

fig = go.Figure()
fig.add_trace(go.Scatter(x=df["Year"], y=df["Absolute_Temp"], mode="lines",
                         name="Global mean temperature (approx)"))
fig.add_hline(y=BASELINE_C, line_dash="dash", annotation_text="1951‚Äì1980 mean ‚âà 14.0¬∞C")
fig.update_layout(title="Observed Global Temperature (approx.)",
                  xaxis_title="Year", yaxis_title="Temperature (¬∞C)",
                  template="plotly_white", width=900, height=450)
fig.show()

# === Cell 5: Core 'Fever Chart' (Line Plot) ===
fig = go.Figure()

fig.add_trace(go.Scatter(
    x=df['Year'], y=df['Anomaly'],
    mode='lines', line=dict(color='firebrick', width=2),
    name='Annual anomaly'
))

fig.add_trace(go.Scatter(
    x=df['Year'], y=df['Anomaly_10yr'],
    mode='lines', line=dict(color='black', width=3),
    name='10-year smooth'
))

fig.add_hline(y=0, line_color='gray', line_dash='dash')
fig.add_hline(y=1.5, line_color='blue', line_dash='dot', annotation_text="+1.5¬∞C target", annotation_position="top left")

fig.update_layout(
    title="Global Temperature Anomaly (¬∞C) ‚Äî The Planet‚Äôs Fever Chart",
    xaxis_title="Year",
    yaxis_title="Temperature Anomaly (¬∞C vs 1951‚Äì1980)",
    template="plotly_white",
    width=900, height=450
)
fig.show()

# Cell 6: Summer & Winter anomaly plots (DJF and JJA)
# Ensure numeric
for c in ["DJF", "JJA"]:
    data[c] = pd.to_numeric(data[c], errors="coerce")

fig = go.Figure()
fig.add_trace(go.Scatter(x=data["Year"], y=data["DJF"], mode="lines", name="Winter (DJF)"))
fig.add_trace(go.Scatter(x=data["Year"], y=data["MAM"], mode="lines", name="Spring (MAM)"))
fig.add_trace(go.Scatter(x=data["Year"], y=data["JJA"], mode="lines", name="Summer (JJA)"))
fig.add_trace(go.Scatter(x=data["Year"], y=data["SON"], mode="lines", name="Autumn (SON)"))
fig.add_hline(y=0, line_dash="dash")
fig.update_layout(title="Seasonal Anomalies",
                  xaxis_title="Year", yaxis_title="Temperature Anomaly (¬∞C)",
                  template="plotly_white", width=900, height=450, legend_orientation="v")
fig.show()

"""# What a 10-year smoothing does

Each plotted point for a given year is replaced by the average anomaly over a 10-year window centered on that year:

$
\text{Smoothed}(y) = \frac{1}{10} \sum_{i = y-4}^{y+5} \text{Anomaly}(i)
$

(if using a centered window of 10 years; sometimes it‚Äôs 5 before + 4 after, or trailing average).

So, for example, the ‚Äúsmoothed‚Äù value for 2015 is the mean of anomalies from roughly 2010‚Äì2019.

# You have two threshold choices, plus a ‚ÄúNone‚Äù option:

| Label       | Value  | Meaning                                                                                                                                                                                                       |
| ----------- | ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **+1.5 ¬∞C** | `1.5`  | Represents the aspirational global warming limit set by the **Paris Agreement (2015)** ‚Äî the world aims to limit temperature rise to **no more than +1.5 ¬∞C above pre-industrial levels**.                    |
| **+2.0 ¬∞C** | `2.0`  | Represents the **upper boundary** of ‚Äúacceptable‚Äù warming ‚Äî beyond which the risk of severe and irreversible climate impacts increases sharply. This is the **formal maximum target** in the Paris Agreement. |
| **None**    | `None` | Disables the threshold line ‚Äî used if you want to view anomalies without any reference limit.                                                                                                                 |

"""

# === Cell 7: Mini Interactive Dashboard (Widgets) ===
years = sorted(df['Year'].unique().tolist())

w_year_min = widgets.IntSlider(min=y_min, max=y_max, value=y_min, description="Start")
w_year_max = widgets.IntSlider(min=y_min, max=y_max, value=y_max, description="End")
w_year_min.continuous_update = False
w_year_max.continuous_update = False
w_smooth = widgets.Dropdown(options=[("None",0),("5-year",5),("10-year",10)], value=10, description="Smoothing")
w_threshold = widgets.Dropdown(options=[("None", None), ("+1.5¬∞C", 1.5), ("+2.0¬∞C", 2.0)], value=1.5, description="Threshold")

out = widgets.Output()

years = sorted(df['Year'].unique().tolist())
y_min, y_max = years[0], years[-1]

def _to_valid_year(x):
    # Handle floats/strings cleanly and clamp to [y_min, y_max]
    try:
        x = int(round(float(x)))
    except Exception:
        x = y_min
    return max(y_min, min(x, y_max))

def render_dashboard(start, end, smooth_k, thresh):
    with out:
        out.clear_output(wait=True)

        # Coerce & sanitize years
        start = _to_valid_year(start)
        end   = _to_valid_year(end)
        if start > end:
            start, end = end, start  # auto-fix reversed range

        d = df[(df['Year'] >= start) & (df['Year'] <= end)].copy()

        # Safe if empty
        if d.empty:
            print(f"No data between {start} and {end}.")
            return

        # Smoothing
        if smooth_k and smooth_k > 1:
            d['Smoothed'] = d['Anomaly'].rolling(window=int(smooth_k), center=True, min_periods=1).mean()
        else:
            d['Smoothed'] = np.nan

        # Plotly figure
        fig = go.Figure()
        fig.add_trace(go.Scatter(x=d['Year'], y=d['Anomaly'], mode='lines',
                                 name='Annual', line=dict(color = "firebrick", width=2)))

        if d['Smoothed'].notna().any():
            fig.add_trace(go.Scatter(x=d['Year'], y=d['Smoothed'], mode='lines',
                                     name=f'{smooth_k}-year smooth', line=dict(color = "black", width=3)))

        fig.add_hline(y=0, line_dash='dash')
        if thresh is not None:
            fig.add_hline(y=float(thresh), line_dash='dot')

        # Only annotate if we have at least one row
        last_row = d.iloc[-1]
        fig.add_trace(go.Scatter(
            x=[last_row['Year']], y=[last_row['Anomaly']],
            mode='markers+text', marker=dict(size=8),
            text=[f"{last_row['Anomaly']:.2f}¬∞C"], textposition="top center",
            name="Latest year"
        ))

        fig.update_layout(
            title="Interactive Fever Chart ‚Äî Explore Years, Smoothing, and Thresholds",
            xaxis_title="Year", yaxis_title="Temperature Anomaly (¬∞C)",
            template="plotly_white", width=900, height=480,
            legend=dict(orientation="h", x=0, y=1.1)
        )
        fig.show()

controls = {"start": w_year_min, "end": w_year_max, "smooth_k": w_smooth, "thresh": w_threshold}
io = interactive_output(render_dashboard, controls)

display(VBox([
    HBox([w_year_min, w_year_max]),
    HBox([w_smooth, w_threshold]),
    out
]), io)

# === Cell 8: Radial donut wall: 1951‚Äì2025, 15 per row √ó 5 rows (bigger donuts) ===
import os, math, urllib.request
import numpy as np, pandas as pd, matplotlib.pyplot as plt
from matplotlib.colors import TwoSlopeNorm
from matplotlib import colormaps
from matplotlib.cm import ScalarMappable
import matplotlib.gridspec as gridspec

file_path = '/content/drive/MyDrive/Python_Pizza_Event/GLB.Ts+dSST.csv'
df = pd.read_csv(file_path, skiprows=1)
df.columns = [c.strip() for c in df.columns]

months = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"]
df = df[df["Year"].astype(str).str.match(r"^\d{4}$", na=False)].copy()
df["Year"] = df["Year"].astype(int)
for m in months:
    df[m] = pd.to_numeric(df[m], errors="coerce")

month_order = {m:i for i,m in enumerate(months, start=1)}
df_m = (df.melt(id_vars="Year", value_vars=months,
                var_name="Month", value_name="Anomaly")
          .dropna(subset=["Anomaly"])
          .assign(MonthNum=lambda d: d["Month"].map(month_order))
          .sort_values(["Year","MonthNum"])
          .reset_index(drop=True))

# 3) Fix the target years: 1951‚Äì2025 (75 years = 5 rows √ó 15)
target_start = 1951
target_years = list(range(target_start, target_start + 75))  # 1951..2025
available_years = set(df_m["Year"].unique())

# 4) Color scale symmetric around 0
max_abs = float(np.nanmax(np.abs(df_m.loc[df_m["Year"].isin(target_years), "Anomaly"].values)))
vlim = round(max_abs + 0.1, 1)
vmin, vmax = -vlim, vlim
cmap = colormaps.get_cmap("RdBu_r")
norm = TwoSlopeNorm(vmin=vmin, vcenter=0.0, vmax=vmax)

# 5) Figure layout: 15 cols √ó 5 rows; bigger donuts
ncols, nrows = 15, 5
# per-cell size (inches): bigger donuts than before
col_w, row_h = 1.15, 1.15
fig_w = ncols * col_w + 0.8    # + colorbar margin
fig_h = nrows * row_h + 0.8

fig = plt.figure(figsize=(fig_w, fig_h), dpi=300)
gs = gridspec.GridSpec(nrows, ncols + 1, width_ratios=[1]*ncols + [0.06],
                       wspace=0.06, hspace=0.10)

# Wedge geometry
theta_centers = np.linspace(0, 2*np.pi, 12, endpoint=False) - np.pi/2  # Jan at top
width = 2*np.pi / 12
inner_radius = 0.33
base_r = inner_radius
bar_h  = 1.0 - inner_radius

# 6) Draw donuts in order (row-major) for the target years
for idx, yr in enumerate(target_years):
    r, c = divmod(idx, ncols)
    ax = fig.add_subplot(gs[r, c], projection="polar")
    ax.set_theta_direction(-1)
    ax.set_theta_zero_location("N")

    if yr in available_years:
        d = df_m[df_m["Year"] == yr][["MonthNum","Anomaly"]]
        vals = {m: np.nan for m in range(1,13)}
        vals.update({int(m): float(v) for m, v in zip(d["MonthNum"], d["Anomaly"])})
    else:
        # Whole year missing ‚Üí leave all wedges blank
        vals = {m: np.nan for m in range(1,13)}

    for k, ang in enumerate(theta_centers, start=1):
        val = vals[k]
        if np.isnan(val):
            ax.bar(ang, bar_h, width=width*0.98, bottom=base_r,
                   edgecolor="#DDDDDD", linewidth=0.5, facecolor="none")
        else:
            ax.bar(ang, bar_h, width=width*0.98, bottom=base_r,
                   color=cmap(norm(val)), edgecolor="white", linewidth=0.5)

    # Year label (slightly larger)
    ax.text(0, base_r-0.06, f"{yr}", ha="center", va="center", fontsize=9)

    # Clean axes
    ax.set_yticklabels([]); ax.set_xticklabels([])
    ax.set_yticks([]);      ax.set_xticks([])
    ax.set_rlim(0, 1.0)

# 7) Vertical colorbar in the extra column
sm = ScalarMappable(norm=norm, cmap=cmap); sm.set_array([])
cax = fig.add_subplot(gs[:, -1])
cbar = fig.colorbar(sm, cax=cax, orientation="vertical")
cbar.set_label("Monthly anomaly (¬∞C; vs 1951‚Äì1980)", rotation=90)

# Title & margins
fig.suptitle("Monthly global mean temperature anomalies 1951‚Äì2025 (vs 1951‚Äì1980)", y=0.995, fontsize=18)
fig.subplots_adjust(left=0.02, right=0.98, top=0.96, bottom=0.04)

# Save & show
out_path = "global_anomaly_radial_1951_2025_15x5.png"
fig.savefig(out_path, bbox_inches="tight")
print(f"Saved: {os.path.abspath(out_path)}")
plt.show()

# ==== Cell 9: annual average temperature anomaly northern vs southern ==========
import pandas as pd
import plotly.graph_objects as go

def load_giss_anomaly_csv(path):
    # Auto-detect header row that contains 'Year', then parse
    d = pd.read_csv(path, skiprows = 1)
    d.columns = [c.strip() for c in d.columns]
    d = d[d["Year"].astype(str).str.match(r"^\d{4}$", na=False)].copy()
    d["Year"] = d["Year"].astype(int)
    d["J-D"] = pd.to_numeric(d["J-D"], errors="coerce")
    d = d.dropna(subset=["J-D"])
    return d[["Year","J-D"]].rename(columns={"J-D":"Anomaly"})

# Example usage (put your local paths or download them first):
gbl = load_giss_anomaly_csv("/content/drive/MyDrive/Python_Pizza_Event/GLB.Ts+dSST.csv")
nh  = load_giss_anomaly_csv("/content/drive/MyDrive/Python_Pizza_Event/NH.Ts+dSST.csv")
sh  = load_giss_anomaly_csv("/content/drive/MyDrive/Python_Pizza_Event/SH.Ts+dSST.csv")

# Plot (uncomment after loading)
fig = go.Figure()
for name, d in [("Global", gbl), ("Northern Hemisphere", nh), ("Southern Hemisphere", sh)]:
     fig.add_trace(go.Scatter(x=d["Year"], y=d["Anomaly"], mode="lines", name=name))
fig.add_hline(y=0, line_dash="dash")
fig.update_layout(title="Regional Anomalies (Annual, J‚ÄìD)", xaxis_title="Year",
                   yaxis_title="Anomaly (¬∞C)", template="plotly_white", width=900, height=450)
fig.show()

# === Cell 10: Robust country-level animated choropleths (Berkeley Earth CSVs) ===
# Accepts columns with extra spaces/punctuation, e.g. "temperature (C) ", "Temperature_C", etc.
# Builds anomalies vs 1951‚Äì1980 and absolute annual temperature maps.

from google.colab import drive
drive.mount('/content/drive', force_remount=True)

# Ensure pycountry is present
try:
    import pycountry
except ImportError:
    !pip -q install pycountry
    import pycountry

import os, re, pandas as pd, numpy as np, plotly.express as px

DATA_DIR = "/content/drive/MyDrive/Python_Pizza_Event/temperature-data"

# Discover CSVs
files = sorted([os.path.join(DATA_DIR, f) for f in os.listdir(DATA_DIR)
                if f.lower().endswith(".csv")])
print(f"Found {len(files)} CSV files")

# --- Header normalizer: lower, strip, remove punctuation, collapse spaces/underscores
def normalize_name(s: str) -> str:
    s = str(s).strip().lower()
    s = s.replace("¬∞", "")  # just in case
    s = re.sub(r"[(){}\[\],:;'/\\\-]+", " ", s)   # punctuation -> space
    s = re.sub(r"\s+", " ", s).strip()            # collapse spaces
    s = s.replace(" ", "_")
    return s

# Map many variants to canonical names
CANON_MAP = {
    "year": "year",
    "yr": "year",
    "month": "month",
    "mo": "month",
    "year_decimal": "year_decimal",
    "decimal_year": "year_decimal",
    "temperature_c": "temperature_c",
    "temperature": "temperature_c",
    "temp_c": "temperature_c",
    "temp": "temperature_c",
    "uncertainty_c": "uncertainty_c",
    "uncertainty": "uncertainty_c",
    "stderr_c": "uncertainty_c",
}
REQUIRED = {"year", "month", "temperature_c"}  # minimal for annual & baseline

def load_one(path):
    country = os.path.basename(path).replace(".csv","").replace("-"," ").strip()
    df = pd.read_csv(path, comment="#")
    # Normalize headers
    norm_cols = [normalize_name(c) for c in df.columns]
    col_map = dict(zip(df.columns, norm_cols))
    df = df.rename(columns=col_map)

    # Canonicalize to expected names
    canon_cols = {}
    for c in df.columns:
        canon = CANON_MAP.get(c, c)
        canon_cols[c] = canon
    df = df.rename(columns=canon_cols)

    # Debug print once per file if missing cols
    if not REQUIRED.issubset(set(df.columns)):
        print(f"‚ö†Ô∏è Skipping {country}: needed {REQUIRED}, found {list(df.columns)[:8]}")
        return None

    # Keep only columns we need
    keep = [c for c in ["year","month","year_decimal","temperature_c","uncertainty_c"] if c in df.columns]
    df = df[keep].copy()

    # Coerce types
    df["year"] = pd.to_numeric(df["year"], errors="coerce").astype("Int64")
    df["month"] = pd.to_numeric(df["month"], errors="coerce").astype("Int64")
    df["temperature_c"] = pd.to_numeric(df["temperature_c"], errors="coerce")
    df = df.dropna(subset=["year","month","temperature_c"]).copy()

    # Sensible year range
    df = df[(df["year"] >= 1850) & (df["year"] <= 2100)]
    if df.empty:
        print(f"‚ö†Ô∏è {country}: no rows after cleaning.")
        return None

    df["Country"] = country
    return df

# Load all
records, failed = [], []
for p in files:
    d = load_one(p)
    if d is None or d.empty:
        failed.append(os.path.basename(p))
    else:
        records.append(d)

if not records:
    raise RuntimeError("No usable files loaded. If one file still fails, share its first 5 header lines.")

df_monthly = pd.concat(records, ignore_index=True)
print(f"Monthly rows: {len(df_monthly):,} | Countries: {df_monthly['Country'].nunique()}  | Failed: {len(failed)}")

# Annual mean temperature per country
df_annual = (df_monthly
             .groupby(["Country","year"], as_index=False)["temperature_c"]
             .mean()
             .rename(columns={"year":"Year","temperature_c":"AnnualTemp_C"}))

# Per-country 1951‚Äì1980 baseline & anomalies
baseline = (df_annual[(df_annual["Year"]>=1951) & (df_annual["Year"]<=1980)]
            .groupby("Country", as_index=False)["AnnualTemp_C"].mean()
            .rename(columns={"AnnualTemp_C":"Baseline_1951_1980_C"}))
df_annual = df_annual.merge(baseline, on="Country", how="left")

# Keep countries with reasonable baseline coverage (>= 20 years in 1951‚Äì1980)
cov = (df_annual[(df_annual["Year"]>=1951) & (df_annual["Year"]<=1980)]
       .groupby("Country")["Year"].nunique())
eligible = set(cov[cov>=20].index)
df_annual = df_annual[df_annual["Country"].isin(eligible)].copy()

df_annual["Anomaly_C"] = df_annual["AnnualTemp_C"] - df_annual["Baseline_1951_1980_C"]

# ISO3 mapping (with a few aliases)
def to_iso3(name):
    aliases = {
        "United States": "USA",
        "Russia": "RUS",
        "Iran": "IRN",
        "Syria": "SYR",
        "Vietnam": "VNM",
        "Bolivia": "BOL",
        "Venezuela": "VEN",
        "Congo": "COG",
        "Democratic Republic of the Congo": "COD",
        "Laos": "LAO",
        "Tanzania": "TZA",
        "Ivory Coast": "CIV",
        "C√¥te d‚ÄôIvoire": "CIV",
        "Cote d'Ivoire": "CIV",
        "Cape Verde": "CPV",
        "Czech Republic": "CZE",
        "Slovakia": "SVK",
        "North Macedonia": "MKD",
        "South Korea": "KOR",
        "North Korea": "PRK",
        "Myanmar": "MMR",
        "Eswatini": "SWZ",
        "Bahamas": "BHS",
        "Gambia": "GMB",
    }
    if name in aliases:
        return aliases[name]
    try:
        return pycountry.countries.lookup(name).alpha_3
    except:
        return None

df_annual["ISO3"] = df_annual["Country"].apply(to_iso3)
unmatched = sorted(df_annual[df_annual["ISO3"].isna()]["Country"].unique())
if unmatched:
    print("‚ö†Ô∏è Unmatched country names (first 15):", unmatched[:15])
df_annual = df_annual.dropna(subset=["ISO3"]).copy()

# === Filter time range for visualization ===
df_annual = df_annual[(df_annual["Year"] >= 1880) & (df_annual["Year"] <= 2020)].copy()
print(f"Showing data from {df_annual['Year'].min()} to {df_annual['Year'].max()}")

# === Animated choropleth ‚Äî Anomaly (1880‚Äì2020) ===
fig_anom = px.choropleth(
    df_annual,
    locations="ISO3",
    color="Anomaly_C",
    hover_name="Country",
    animation_frame="Year",
    color_continuous_scale="RdBu_r",
    range_color=[-3, 3],
    title="Country-level Temperature Anomalies (vs 1951‚Äì1980, 1880‚Äì2020)",
    labels={"Anomaly_C": "Anomaly (¬∞C)"},
)
fig_anom.update_geos(
    projection_type="natural earth",
    showcoastlines=True, showcountries=True, showland=True, landcolor="lightgray"
)
fig_anom.update_layout(width=980, height=560)
fig_anom.show()

# === Animated choropleth ‚Äî Absolute (¬∞C) (1880‚Äì2020) ===
abs_min, abs_max = float(df_annual["AnnualTemp_C"].min()), float(df_annual["AnnualTemp_C"].max())
fig_abs = px.choropleth(
    df_annual,
    locations="ISO3",
    color="AnnualTemp_C",
    hover_name="Country",
    animation_frame="Year",
    color_continuous_scale="Turbo",
    range_color=[abs_min, abs_max],
    title="Country-level Absolute Annual Temperature (¬∞C, 1880‚Äì2020)",
    labels={"AnnualTemp_C": "Annual Temp (¬∞C)"},
)
fig_abs.update_geos(
    projection_type="natural earth",
    showcoastlines=True, showcountries=True, showland=True, landcolor="lightgray"
)
fig_abs.update_layout(width=980, height=560)
fig_abs.show()

# ====== Cell 11: Forecasting temperature anomaly using Facebook's prophet algorithm upto 2100 ===========
#!pip install prophet

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from prophet import Prophet
from datetime import datetime

# Load the data
df = pd.read_csv('/content/drive/MyDrive/Python_Pizza_Event/GLB.Ts+dSST.csv', skiprows=1)

# Prepare data for Prophet (needs 'ds' and 'y' columns)
# Using the J-D (annual mean) column
prophet_data = []
for _, row in df.iterrows():
    year = int(row['Year'])
    annual_mean = row['J-D']

    # Skip missing values (marked as ***)
    if annual_mean != '***':
        prophet_data.append({
            'ds': pd.Timestamp(year=year, month=7, day=1),  # Mid-year date
            'y': float(annual_mean)
        })

df_prophet = pd.DataFrame(prophet_data)

# Initialize and fit Prophet model
model = Prophet(
    changepoint_prior_scale=0.05,  # Flexibility of trend changes
    seasonality_mode='additive',
    yearly_seasonality=False,
    weekly_seasonality=False,
    daily_seasonality=False,
    interval_width=0.68  # 1 standard deviation (~68% confidence interval)
)

# Fit the model
model.fit(df_prophet)

# Create future dataframe up to 2100
future_years = pd.date_range(
    start=df_prophet['ds'].min(),
    end=pd.Timestamp(year=2100, month=7, day=1),
    freq='YS'  # Year start frequency
)
future = pd.DataFrame({'ds': future_years})

# Make predictions
forecast = model.predict(future)

# Find when forecast exceeds 1.5¬∞C
forecast['year'] = forecast['ds'].dt.year
exceed_1_5 = forecast[(forecast['yhat'] >= 1.5) & (forecast['year'] > df_prophet['ds'].dt.year.max())]
if not exceed_1_5.empty:
    year_exceed_1_5 = exceed_1_5.iloc[0]['year']
    temp_at_exceed = exceed_1_5.iloc[0]['yhat']
else:
    year_exceed_1_5 = None
    temp_at_exceed = None

# Create the plot
fig, ax = plt.subplots(figsize=(15, 8))

# Plot historical observations
historical_years = df_prophet['ds'].dt.year
ax.scatter(historical_years, df_prophet['y'],
          color='#3b82f6', s=20, alpha=0.7,
          label='Observed Data', zorder=4)

# Plot FULL forecast line (including historical period for smooth curve)
forecast_years = forecast['ds'].dt.year
ax.plot(forecast_years, forecast['yhat'],
        '-', color='#f97316', linewidth=2.5,
        label='Prophet Forecast', zorder=3)

# Highlight future forecast portion
future_mask = forecast['ds'] >= df_prophet['ds'].max()
ax.plot(forecast_years[future_mask], forecast['yhat'][future_mask],
        '-', color='#dc2626', linewidth=3, alpha=0.8, zorder=3)

# Plot standard deviation uncertainty band (only for future)
ax.fill_between(forecast_years[future_mask],
                forecast['yhat_lower'][future_mask],
                forecast['yhat_upper'][future_mask],
                color='#fed7aa', alpha=0.5,
                label='¬±1 Std Dev (68% CI)', zorder=1)

# Add reference lines
ax.axhline(y=0, color='gray', linestyle='--', linewidth=1, alpha=0.5)
ax.axhline(y=1.5, color='red', linestyle='--', linewidth=2.5,
          alpha=0.8, label='1.5¬∞C Paris Target')

# Mark when 1.5¬∞C is exceeded
if year_exceed_1_5:
    ax.axvline(x=year_exceed_1_5, color='red', linestyle=':',
              linewidth=2, alpha=0.6, zorder=2)
    ax.plot(year_exceed_1_5, temp_at_exceed, 'r*',
           markersize=20, markeredgecolor='darkred',
           markeredgewidth=1.5, zorder=5,
           label=f'1.5¬∞C Exceeded ({year_exceed_1_5})')

    # Add annotation
    ax.annotate(f'1.5¬∞C Exceeded\nin {year_exceed_1_5}',
               xy=(year_exceed_1_5, 1.5),
               xytext=(year_exceed_1_5 + 8, 1.2),
               fontsize=11, fontweight='bold',
               bbox=dict(boxstyle='round,pad=0.5', facecolor='yellow', alpha=0.8),
               arrowprops=dict(arrowstyle='->', color='red', lw=2))

# Formatting
ax.set_xlabel('Year', fontsize=13, fontweight='bold')
ax.set_ylabel('Temperature Anomaly (¬∞C)', fontsize=13, fontweight='bold')
ax.set_title('Global Temperature Anomaly Forecast to 2100\nProphet Model with ¬±1 Standard Deviation',
            fontsize=15, fontweight='bold', pad=20)
ax.legend(loc='upper left', fontsize=11, framealpha=0.95)
ax.grid(True, alpha=0.3, linestyle='--')
ax.set_xlim(1880, 2100)
ax.set_ylim(-0.8, 3.0)

# Add text box with statistics
last_observed = df_prophet.iloc[-1]['y']
last_year = df_prophet.iloc[-1]['ds'].year
forecast_2050 = forecast[forecast['year'] == 2050]['yhat'].values[0]
forecast_2100 = forecast[forecast['year'] == 2100]['yhat'].values[0]
std_2100 = (forecast[forecast['year'] == 2100]['yhat_upper'].values[0] - forecast_2100)

stats_text = f"""Key Statistics:
Last Observed ({last_year}): {last_observed:.2f}¬∞C
Forecast 2050: {forecast_2050:.2f}¬∞C
Forecast 2100: {forecast_2100:.2f}¬∞C
Total Increase: +{forecast_2100 - last_observed:.2f}¬∞C
Std Dev 2100: ¬±{std_2100:.2f}¬∞C"""

if year_exceed_1_5:
    stats_text += f"\n1.5¬∞C Exceeded: {year_exceed_1_5}"

ax.text(0.98, 0.02, stats_text, transform=ax.transAxes,
        fontsize=10, verticalalignment='bottom', horizontalalignment='right',
        bbox=dict(boxstyle='round', facecolor='lightblue', alpha=0.9, pad=0.8))

plt.tight_layout()
plt.savefig('temperature_forecast_2100.png', dpi=300, bbox_inches='tight')
plt.show()

# Print detailed forecast statistics
print("\n" + "="*70)
print("PROPHET FORECAST SUMMARY".center(70))
print("="*70 + "\n")

print(f"Last Observed Temperature Anomaly ({last_year}): {last_observed:.3f}¬∞C")
print(f"\nForecast for 2050: {forecast_2050:.3f}¬∞C")
print(f"Forecast for 2100: {forecast_2100:.3f}¬∞C")
print(f"\nProjected increase by 2100: +{forecast_2100 - last_observed:.3f}¬∞C")
print(f"Standard deviation at 2100: ¬±{std_2100:.3f}¬∞C")

if year_exceed_1_5:
    print(f"\n‚ö†Ô∏è  CRITICAL: 1.5¬∞C threshold will be EXCEEDED in {year_exceed_1_5}")
    print(f"    Temperature at crossing: {temp_at_exceed:.3f}¬∞C")
else:
    print("\n‚úì 1.5¬∞C threshold not exceeded in forecast period")

# Show forecast table for key years
key_years = [2025, 2030, 2035, 2040, 2050, 2060, 2070, 2080, 2090, 2100]
print("\n" + "="*70)
print("FORECAST BY KEY YEARS".center(70))
print("="*70)
print(f"{'Year':<6} | {'Forecast':>10} | {'Lower':>10} | {'Upper':>10} | {'Std Dev':>10}")
print("-" * 70)
for year in key_years:
    year_data = forecast[forecast['year'] == year]
    if not year_data.empty:
        yhat = year_data['yhat'].values[0]
        lower = year_data['yhat_lower'].values[0]
        upper = year_data['yhat_upper'].values[0]
        std = (upper - yhat)
        marker = " ‚ö†Ô∏è" if yhat >= 1.5 else ""
        print(f"{year:<6} | {yhat:>9.3f}¬∞C | {lower:>9.3f}¬∞C | {upper:>9.3f}¬∞C | ¬±{std:>8.3f}¬∞C{marker}")

print("="*70 + "\n")

# Export forecast data to CSV
forecast_export = forecast[['year', 'yhat', 'yhat_lower', 'yhat_upper']].copy()
forecast_export.columns = ['Year', 'Forecast', 'Lower_Bound', 'Upper_Bound']
forecast_export['Exceeds_1.5C'] = forecast_export['Forecast'] >= 1.5
forecast_export.to_csv('temperature_forecast_2100.csv', index=False)

print("‚úì Forecast data exported to 'temperature_forecast_2100.csv'")
print("‚úì Plot saved as 'temperature_forecast_2100.png'")
print("\nNote: Forecast assumes continuation of recent trends and does not")
print("      account for potential mitigation efforts or tipping points.")

# === Cell 12: Co2 emission rate in ppm over time  ===
from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import matplotlib.pyplot as plt

# Read the CSV file
df = pd.read_csv('/content/drive/MyDrive/Python_Pizza_Event/co2_annmean_mlo.csv', comment='#')

# Create the figure and axis
fig, ax = plt.subplots(figsize=(12, 6))

# Plot the main data
ax.plot(df['year'], df['mean'], linewidth=2, color='#d62728', marker='o',
        markersize=3)

# Fill area under the curve for visual effect
#ax.fill_between(df['year'], df['mean'], alpha=0.3, color='#d62728')

# Customize the plot
ax.set_xlabel('Year', fontsize=12, fontweight='bold')
ax.set_ylabel('CO‚ÇÇ Concentration (ppm)', fontsize=12, fontweight='bold')
ax.set_title('Atmospheric CO‚ÇÇ Concentrations at Mauna Loa Observatory\n(1959-2024)',
             fontsize=14, fontweight='bold', pad=20)

# Add grid
ax.grid(True, alpha=0.3, linestyle='--')

# Add some statistics as text
start_co2 = df['mean'].iloc[0]
end_co2 = df['mean'].iloc[-1]
increase = end_co2 - start_co2
percent_increase = (increase / start_co2) * 100

stats_text = f'Total Increase: {increase:.2f} ppm ({percent_increase:.1f}%)\n'
stats_text += f'{df["year"].iloc[0]}: {start_co2:.2f} ppm ‚Üí {df["year"].iloc[-1]}: {end_co2:.2f} ppm'

ax.text(0.02, 0.98, stats_text, transform=ax.transAxes,
        fontsize=10, verticalalignment='top',
        bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))

# Adjust layout and display
plt.tight_layout()
plt.savefig('co2_emissions_chart.png', dpi=300, bbox_inches='tight')
plt.show()

print(f"Chart saved as 'co2_emissions_chart.png'")
print(f"\nKey Statistics:")
print(f"Starting CO‚ÇÇ ({df['year'].iloc[0]}): {start_co2:.2f} ppm")
print(f"Ending CO‚ÇÇ ({df['year'].iloc[-1]}): {end_co2:.2f} ppm")
print(f"Total Increase: {increase:.2f} ppm ({percent_increase:.1f}%)")
print(f"Average Annual Increase: {increase/(df['year'].iloc[-1]-df['year'].iloc[0]):.2f} ppm/year")

"""### ‚úçÔ∏è Your Data Story Task(2‚Äì4 sentences)
- **Setup:** What question are we exploring? (e.g., Is the planet running a fever?)
- **Conflict:** What trend or contrast emerges? (e.g., warming accelerates after 1980; approaching +1.5¬∞C)
- **Falling Action:** What are the implications? Who is impacted and how?
- **Resolution:** What should we consider doing? (e.g., mitigation targets; adaptation urgency)



"""